# 暴力破解

假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？

如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：

* 如果当前字符匹配成功（即S\[i\] == P\[j\]），则i++，j++，继续匹配下一个字符；
* 如果失配（即S\[i\]! = P\[j\]），令i = i - \(j - 1\)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。

  理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下：

```
<?php

$str = "BBC ABCDAB ABCDABCDABDE";
$_str = "ABCDABD";

function violentMath($str, $_str) {
    $strlen  = strlen(strtolower($str));
    $_strlen = strlen(strtolower($_str));
    $i = 0;
    $j = 0;
    while ($i < $strlen && $j < $_strlen) {
       if ($str[$i] == $_str[$j]) {
           ++$i;
           ++$j;
       } else {
          $i = $i - $j + 1;
          $j = 0;
       }
    }
    if ($j == $_strlen) {
      return $i - $j;
    }
    return -1;
}
echo violentMath($str,$_str);
```

举个例子，如果给定文本串S“BBC ABCDAB ABCDABCDABDE”，和模式串P“ABCDABD”，现在要拿模式串P去跟文本串S匹配，整个过程如下所示：

\_1.\_S\[0\]为B，P\[0\]为A，不匹配，执行第②条指令：“如果失配（即S\[i\]! = P\[j\]），令i = i - \(j - 1\)，j = 0”，S\[1\]跟P\[0\]匹配，相当于模式串要往右移动一位（i=1，j=0）

> ![](http://img.blog.csdn.net/20140723224710203)

_2_. S\[1\]跟P\[0\]还是不匹配，继续执行第②条指令：“如果失配（即S\[i\]! = P\[j\]），令i = i - \(j - 1\)，j = 0”，S\[2\]跟P\[0\]匹配（i=2，j=0），从而模式串不断的向右移动一位（不断的执行“令i = i - \(j - 1\)，j = 0”，i从2变到4，j一直为0）

> ![](http://img.blog.csdn.net/20140726213551553)

_3_

. 直到S\[4\]跟P\[0\]匹配成功（i=4，j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：“如果当前字符匹配成功（即S\[i\] == P\[j\]），则i++，j++”，可得S\[i\]为S\[5\]，P\[j\]为P\[1\]，即接下来S\[5\]跟P\[1\]匹配（i=5，j=1）

> ![](http://img.blog.csdn.net/20140726213602848)

_4_

. S\[5\]跟P\[1\]匹配成功，继续执行第①条指令：“如果当前字符匹配成功（即S\[i\] == P\[j\]），则i++，j++”，得到S\[6\]跟P\[2\]匹配（i=6，j=2），如此进行下去

> ![](http://img.blog.csdn.net/20140726213343578)

_5_. 直到S\[10\]为空格字符，P\[6\]为字符D（i=10，j=6），因为不匹配，重新执行第②条指令：“如果失配（即S\[i\]! = P\[j\]），令i = i - \(j - 1\)，j = 0”，相当于S\[5\]跟P\[0\]匹配（i=5，j=0）

> ![](http://img.blog.csdn.net/20140726213353687)

_6_

. 至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了S\[9\]、P\[5\]，但因为S\[10\]跟P\[6\]不匹配，所以文本串回溯到S\[5\]，模式串回溯到P\[0\]，从而让S\[5\]跟P\[0\]匹配。

![](http://img.blog.csdn.net/20140726213631208)

而S\\[5\\]肯定跟P\\[0\\]失配。为什么呢？因为在之前第4步匹配中，我们已经得知S\\[5\\] = P\\[1\\] = B，而P\\[0\\] = A，即P\\[1\\] != P\\[0\\]，故S\\[5\\]必定不等于P\\[0\\]，所以回溯过去必然会导致失配。那有没有一种算法，让i 不往回退，只需要移动j 即可呢？  

答案是肯定的。这种算法就是本文的主旨KMP算法，它利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置



